#+TITLE: Rust in 2 hours
#+AUTHOR: Aleksandr Petrosyan

* Preface
This is a high level overview document about the Rust programming language.  The reason this document exists is to provide people who have to learn Rust at some point a general overview, without the usual dogmatism.  This is good to nudge teams that were considering Rust to using it and to avert catastrophe for projects for which it is a poor fit.

I firmly believe that either a blind endorsement or misinformed dogmatic rejection of the language are both detrimental to society.  Despite my humble expertise in Rust, and a relatively good overview of programming languages, I believe that this document can be a valuable tool.  However, this is in no way an in-depth analysis, and I would recommend using this document as a start for one's own research using the provided resources.

* Overview
Rust is a multi-paradigm programming language that supports procedural, object-oriented and functional programming as well as relatively niche paradigms such as actor-based programming.  However, it does not fit into either of those niches completely.  In conjunction with relatively good performance, a vibrant community and a reliance on the =libc= as the only runtime component, Rust can fill the niches previously occupied by C++, while its choice to support a limited form of compile-time user-specified code transformation/generation (via procedural macros) allow it to compete with Python and Go for backend development.

Rust is a complex language.  Much of its complexity stemming from the rules imposed by the language designers, rather than the sheer number of features.  Procedural macros allow library developers to impose additional rules, which more often than not allows Rust to be explored by trial and error.  For someone well-versed in Haskell and C++, required reading to learn Rust can be reduced to none, as the process from installing =rustup= to running =cargo build= is self documenting.

Rust is a language that plants itself firmly in the camp of pragmatic long feedback cycle development.  A proficient Rust engineer is able to skirt around and anticipate compilation errors, which given strict typing, strong soundness requirements and many issues particularly pertaining to incomplete and/or unimplemented features, is a lot harder than one would aniticipate.

Rust programming is unlike programming in other systems programming languages, as it does not allow the programmer to defer confronting problems, and over-abstract to hide poor design decisions.  It is a language best suited for programming libraries, with a similarly robust toolkit for producing complete applications either using the CLI or graphical toolkits.

It is a language that is used in the vast majority of blockchain systems.  Among the features that make it a good choice are
1) Borrow checking, which elides the need for garbage collection and  providing similar memory safety.
2) A sane concurrent programming paradigm, making it easier to write both threaded and asynchronous multiprocessing applications.
3) Strong static analysis tools, preventing implicit programming errors, such as over/under flow, unhandled error conditions, type mismatch etc.
4) Robust coverage of LLVM targets.  It should be noted that due to the dependence on the platform-specific =libc=, the =zig= programming language has slightly better coverage.
5) Rust is the preferred language for working with WASM both client and server-side.
6) Strong FFI programming paradigm.  One does not have an implicit ABI, and one has thorough control over memory layout as well as potential pitfalls.
7) Rust allows the user to specify additional compile-time constraints with thorough guidance via procedural macros.


Rust is used for the implementation of some of the ledgers in the Ethereum protocol, and all of the Solana software stack.  It is used in Parity Substrate (Polkadot ecosystem), and with very few exceptions is the language of choice for writing one's own blockchain protocol.

Finally, Rust is the first language since C to be used for the Linux kernel.  It was directly endorsed by the white house in lieu of traditional programming in "memory unsafe" languages such as C, C++, FORTRAN, Pascal, Ada, and many more.

It is a flourishing ecosystem of libraries, packages and professionals.

* Procedural Rust



Rust has a pragmatic approach to procedural programming.  In most situations, one is encouraged to write the code in a procedural style, without over-abstraction.

** Hello world
To start things off, this is what a hello-world program would look like[fn:1].
#+BEGIN_SRC rust
  fn main() {
	  println!("Hello world");
  }
#+END_SRC
The =main= function is an OS entrypoint.  The Rust compiler abstracts the unix-specific aspects of the entrypoint: note the absence of arguments as input, the usage of the =println!= macro in lieu of the =libc= =printf= function, lack of return in either the signature of main, or implicit =return 0=.  For all intents and purposes, these abstractions are almost never a problem, and allow the programmer to live in a world of coherent abstractions.

** TODO Crates, compilation, cargo

** Variables

Like many similar languages, Rust supports a Von-Neumann model:  variables can be regarded as containers for values.

Each container has exactly one type.  The following primitive numerical types are supported:

| Type |
|------|
| u8   |
| u16  |
| u32  |
| u64  |
| u128 |
#+CAPTION: Unsigned integer types

| Type |
|------|
| i8   |
| i16  |
| i32  |
| i64  |
| i128 |
#+CAPTION: Signed integer types

Each container must be initialised to a value, before use, that is of the same type as the container.  Failure to do so is a compilation error, Rust can keenly track these situations, more on that later.  The following is a comprehensive example of possible variable declarations.
#+BEGIN_SRC rust
  let good_type: u64 = 0_u64;
  let good_deferred_init;

  let mut inferred_type = 0_usize;
  let bad_value: u64 = -1_i32;	// bad: unsigned box, signed value
  let bad_type: u64 = 0_usize;	// bad: usize is not the same as u64
  good_deferred_init = 3;			// ok: type i32
  let bad_init;					// bad: not initialised at all
#+END_SRC

All variables must be initialised once.  The programmer must opt into mutating the value afterwards.

Each variable is confined to a scope, that is delimited by curly brace pairs.  A =let= expression can be used to shadow a variable within a particular scope, with a type that might be different.

#+BEGIN_SRC rust
  start = 0_i32;
  // Illegal, need `let`
  let start = 0_u8;
  // legal init
  let start = 0_i8;
  // legal shadow
  {
	  let mut start = 0_u16;
	  // legal shadow
	  start += 1_u16;					// No ++ operator :(
	  // legal, this `start` is mutable.
  }
  start -= 1_i8;
  // Illegal.

  let start: u128;
  // All legal
  start = 0_u64;
  // illegal, because the type of `start` must be `u128`
#+END_SRC



** Expressions, Control flow

Rust is an expression-based language.  An expression is composed of literals, variables, function calls, and operators[fn:2].  Variables are evaluated eagerly.  There are two distinct types, ones which indicate a location, (called place expressions) and the rest are value expressions.

All expressions produce a value, some expressions have an effect on the surrounding code.  A literal is an expression that only produces a value.  An assignment, by contrast produces both a value, and an effect, and arguably the effect is more important. All values produced by expressions can be assigned to a variable.

A block: region delimited by curly braces, is also an expression:
#+BEGIN_SRC rust
  let block = {
	  let answer = 22;
	  let question = 20;
	  question;
	  answer + question
  };
  // block == 42
  #+END_SRC
Note the absence of the semicolon in the line containing the expression =answer+question=, but the presence of a semicolon after the initialisation.  If the semicolon were added, this would still be valid Rust, but the value (and type) of block would be =()= known as =unit=.  This special type is what most expressions in Rust evaluate to, even though you as a programmer are unlikely to write it explicitly.

Rust supports many of the usual ALGOL-heritage control constructs.  This includes =if/else=, =while=, =for=.  In Rust, these constructs are also expressions, meaning that they produce a value.

The boolean conditional =if= works by evaluating the expression that follows the keyword, and then evaluating the contents of the following curly braces.  For example:

  #+BEGIN_SRC rust
	let value_of_if = if true { false; }
	// value_of_if == ()
#+END_SRC
An =if= is allowed to evaluate to the trivial type =()=.  Any other value with only one =if= would lead to inconsistency in the type of the =value_of_if= variable.

If the =if= has an =else= block, however, the value is allowed to be of any other type, provided both the types of the =if= and =else= are the same:
#+BEGIN_SRC rust
let answer: i32 = if question_about_meaning_of_life { 42 } else { -1 }
#+END_SRC

For obvious reasons, the =while= loop operates much like the lone =if= expression, evaluating to =()=.

The =for= loop operates more similarly to Python or PASCAL, in that it provides a bound value that is taken from a particular collection.  The precise mechanism for this we shall cover in a later chapter.  Similarly to =while= and despite there being a natural[fn:3] value to which the =for= expression could evaluate, it too evaluates to =()=.

These loops interact in the usual way with the =break= and =continue= keywords.  They typically either exit or skip the execution of statements in the first enclosing loop.  If there is more than one loop, the programmers disambiguate by assigning labels.

#+BEGIN_SRC rust
  'outer: for i in 1..=5 {
	  for j in 1..=200 {
		  if j > 4 {
			  break;
			  // equivalent to `continue 'outer;`
		  }
		  if i >= 2 {
			  break 'outer;
		  }
	  }
  }
#+END_SRC
One keyword that differentiates Rust from other programming languages is the =loop= keyword.  It is an endless loop, that must be exited with the =break= keyword, or not at all (/e.g./ in event loops, REPL /etc./).  This is also the reason for differentiating loop labels with single quote marks (/e.g./ ='outer= instead of =outer=); because =loop= expressions are allowed to evaluate to non-trivial values.  In this case =break= can be used as a regular =return= statement in a function[fn:4].

#+BEGIN_SRC rust
let (mut a, mut b) = (1, 1);
let result = loop {
	if b > 10 {
		break b;
	}
	let c = a + b;
	a = b;
	b = c;
};
#+END_SRC


#+BEGIN_ASIDE
This convention might seem problematic at first; indeed this was one of the main criticisms of Pascal.  However, this convention allows shorter code, that is also more explicit about the dependency chains.

It is a common situation where a lot of values must be constructed, so that then a few other dependent values are initialised.  This code if written out linearly is difficult to read, as it is a dry sequence of definitions and assignments.  However, if the base values are only needed to construct the dependent values, one can group those into anonymous blocks.

This can be extended to situations wherein state is being modified as well.  Imposing a scope and shadowing temporarily mutable values, allows one to know which values are yet to be mutated, and which are immutable.

This approach is reminiscent of [[http://number-none.com/blow/blog/programming/2014/09/26/carmack-on-inlined-code.html][style C of John Carmack]], but with crucial improvements.  Namely, the local variables are localised, the variables whose state is used more than once are naturally declared at the outer scope, giving one a structural insight into the code organisation.  The comments are optional, and the function of a code fragment can be gleaned from the value that is being constructed.  As such, it provides the sequential narrative of inline declarations, as well as the readability improvements associated to grouping logically connected operations.
#+END_ASIDE

** Arrays, borrows, slices

Rust supports contiguous homogeneously typed collections at the language level.  The following is an example of an array of bytes, that is the ASCII string for "hello world".
#+BEGIN_SRC rust
let array: [u8; _] = b"hello world";
#+END_SRC
In this example, we could have omitted the type signature, as it would be inferred.  We chose to specify the type of each element: =u8=, but not to specify the number of elements.  We have also chosen to use the array literal syntax for ASCII strings.  Including any UTF-8 non-ASCII characters would result in a compilation error.

Like in PASCAL, arrays of different lengths are considered different types.
#+BEGIN_SRC rust
  let array: [u8; 3] = b"hello world"; // Type error; length
  let array: [char; 3] = ['a', 'b', 'c']; // OK
  let array: [char; 4] = "abcd";			// OK
  let array: [u8; 4] = "abcd";			// Type error; char is not u8
  let array: [char, 4] = b"abcd";			// Type error; u8 is not the same type as char
#+END_SRC
It should also be noted, that =char= is a distinct type from =u8=, and that Rust strings (more on them later), are not arrays of either =char= or =u8=.  Consequently, the problems that plagued PASCAL do not affect Rust, for reasons that shall become clear shortly.

Rust does not support C/C++ style references and pointers.  For historical reasons Rust follows the convention of those languages for its closest analogues to those concepts, however, the semantics attached to those analogues are very different.

While variables typically have a memory address, unlike most procedural languages, Rust enforces that these memory addresses be taken only while the variables are in scope.  So for example the following code shall fail to compile:

#+BEGIN_SRC rust
  let reference: &i32;

  {
	  let temp = 0;
	  reference = &temp;
  }

  *reference = 42
  // UB: temp must be `free`d by now.
#+END_SRC

All addresses in Rust can be safely considered to be valid, unless a subsystem of the Rust compiler, known as the borrow checker, states that a variable, in this case =temp= doesn't live long-enough[fn:5].

For reasons that shall become apparent later, Rust refers to these addresses as borrows, to delineate that unlike in C, where taking a reference is a simple operation, in Rust, the same operation has more implications.  The inverse operation to a =borrow= is a =dereference= and it largely follows the same conventions as C.

Unlike C, a variable in Rust is only mutable if explicitly marked as mutable.  An even stricter requirement is imposed on references that are allowed to mutate the borrowed value, known as mutable borrows.  To mutate elements of an array, both the array itself as well as the borrow of said array must be marked explicitly as mutable.  For example:
#+BEGIN_SRC rust
  let mut vec: [u8; 3] = [1, 2, 3];

  for i in &mut vec {
	  *i += 50;
  }

  // vec = [51, 52, 53]
#+END_SRC

The borrow checker statically verifies that there is no converting an immutable reference to a mutable one, similar to casting away =const= in C.  Any attempt to take another mutable or immutable[fn:7] reference to the same array =vec= (for example inside the =for= loop)  would also be a compilation error, as only one mutable borrow is allowed at a time.

#+BEGIN_ASIDE
The borrow checker algorithm is not perfect; whenever it sees code that *could* be borrowing the same variable's address mutably twice, it will reject that code.

For situations where that would lead to great inefficiencies, users are to use =unsafe=, however, it is highly recommended to avoid =unsafe=, unless one has exhausted all other possibilities.
#+END_ASIDE

One final point to cover is references to arrays.  In Rust arrays of two different sizes have two different types.  This necessitates introducing two ways of borrowing an array: =&[u8; 3]= which is a single machine word "pointer" to the beginning of the array (with the size known at compile time), and =&[u8]=, a fat pointer containing the length as part of the runtime parameters, which is known as a slice.

Both use the same syntax, but given that compile time information provides room for optimisations, the programmer is given no control over which borrow occurs for any given scenario.

** Operators

Rust operators are strictly typed.  This means that in =a+b=, both =a= and =b= must be of the same type.  Some types, for which other languages provide an automatic coercion, /e.g./ =u8= to =u16=, must be explicitly cast to the appropriate type:
#+BEGIN_SRC rust
  let a = 1u8;
  let b = 2u16;
  let c = a + (b as u8);			// Truncation warning
  let d = (a as u16) + b;
  let err = a + b;				// Type Error
#+END_SRC

Rust permits truncating conversions, but the static analysis tool =clippy= is able to quickly find and warn about these problems.

Rust operators are overloaded and user-overload-able, via the =trait= mechanism which we shall cover in the object-oriented part of this book.  For the time being, suffice it to say that the plus operator that acts on =u16= is not the same as =+= acting on =u8=.  This shall become important when dealing with strings.

** Functions

Rust calls procedures[fn:8] functions, without differentiating side-effect-free functions from procedures.

Function signatures as well as argument type declarations are right-associative.

#+BEGIN_SRC rust
  fn function(arg1: u32, arg2: i32, arg3: u128) -> u128 {
	  arg3
  }
#+END_SRC
Functions  evaluate to the value of the block that constitutes its body.  In this example the function body could be rewritten to =return arg3;= without changing anything.

No type outside the function body is inferred, so the function must always specify the type of each argument.

All data that the function is allowed to read comprises its arguments and special global values defined using the =const= keyword.  For the time being it can be assumed that this implies that no global shared state is permitted, but as we shall see later, this is not the case.

The functions must rigidly adhere to the type signature.  No implicit conversions in standard functions is permitted to occur, so arguments must be explicitly cast at the call site.

Functions that do not participate in C-ABI linkage are not variadic.

** Introduction to Macros

Macros are one of the key differentiating factors of Rust from other systems programming languages.  Macros are typically used to generate valid Rust code that no reasonable human being would be able to interpret or write, in addition to imposing other restrictions.

Macros do not have access to the type system, but thanks to strict typing, macros can typically do rudimentary type checking by hijacking the type checking in the generated code.

As such, there are multiple types of macros, of which we shall only cover one type: function-like macros.

Unlike functions, which have a fixed number of arguments, and are strictly type checked, a function-like macro can accept any form of input.  Technically all macros accept one argument, but that argument can be a delimited collection of expressions, which act as if they were a variadic function or macro.

We have already seen one example, the =println!= macro.  All function like macros are postfixed by an exclamation mark to differentiate them from functions.

** The formatting mini-language

The =println= macro is worth going into.  The first "argument" of =println!= is a format "string".  Unlike =printf= in C, this argument string is not an actual string[fn:11], and must be specified in-line as a string literal.  This format string is parsed at compilation time, and if there are no format markers, the string is printed as is.

The format markers constitute a mini-language.  Most primitive types can be printed directly, via an empty pair of curly braces:
#+BEGIN_SRC rust
  let answer = 42;
  println!("Hello world! The answer is {}", answer);
#+END_SRC
The empty pair is called a positional format marker, and for each positional format marker, there must be a comma delimited in-line list of variables that must be printed, in the order specified by positional format markers.

Named format markers allow one to assign a name in the format string, and in the variable list, assign variables to the named markers.  If the name of the format marker corresponds to an in-scope variable, the assignment can be omitted.

#+BEGIN_SRC rust
  let world_ordinal = 3;
  println!("Hello World number {world}! The answer is {answer}", world=world_ordinal)
#+END_SRC

#+BEGIN_ASIDE
My personal recommendation is to consider using /named/ format markers almost always; definitely in cases where there's more than one format marker.

Additionally, I should advise against mixing positional and named markers.
#+END_ASIDE

One has access to a rich set of formatting options, including
- fill,
- alignment,
- width
- formatting of numerical literals in many bases, including binary, hexadecimal, octal.
- Precision control for floating point numbers
- Localisation (for locales where the decimal separator is different) etc.

#+BEGIN_ASIDE
The =println!= and =eprintln!= macros (printing to =stderr=) are included in the so-called prelude.  This is a collection of commonly used constructs that are imported by default.
#+END_ASIDE


** Modules

Rust has a robust system of modules and namespaces.  Many objects, including constants, functions and modules accept visibility modifiers.  Everything is private by default, unless specified otherwise by prefixing the =pub= keyword.

Modules constitute a tree, with one root, known as the top-level module[fn:9].  The nested modules can refer to the top level module as =crate=, and their immediate[fn:10] parent module as =super=.   To access members within a module, one uses the =::= syntax borrowed from C++.

#+BEGIN_SRC rust
  pub mod thing {
	  pub const CONST: u8 = 32;

	  mod thing2 {
		  pub const CONST: u8 = 42;
		  // Warning, module private, can't see the `pub`.
	  }

	  pub(super) thing3 {
		  pub const CONST: u8 = 42;
	  }
	  pub const CONST2: u8 = thing3::CONST;
  }

  mod thing2 {
	  pub const CONST: u8 = super::thing::CONST;
	  pub mod thing3 {
		  pub const CONST: u8 = crate::thing::CONST;
		  // This is identical to `thing2::CONST`
	  }
	  pub const CONST2: u8 = super::thing::thing3::CONST;
	  // Error, thing3 is visible to `thing`
  }

  mod file_mod;			// Lives in a file `file_mod.rs`
#+END_SRC

All constructs must be either fully qualified or imported with the =use= keyword.

#+BEGIN_ASIDE
Unlike C++, the usage of =use= is not problematic.  Rust does not allow two functions with separate definitions to be imported into the same namespace, so a functional call always resolves unambiguously and the definition even for generic functions is always local.
#+END_ASIDE

The =use= keyword allows shorthand import of multiple constructs, with short-hand notation for all public items belonging to a particular module.

#+BEGIN_SRC rust
  use file_module::submod::{fun1, fun2, self}
  // Allows referring to `submod::` directly

  mod file_module;
  // The mod declaration can come after the imports

  pub mod thing {
	  use super::*;
	  // modules don't inherit parent imports
  }
#+END_SRC

Use statements are effective for the block in which they are written.  So, having use statements confined to a block is useful when one wants to avoid using fully-qualified paths[fn:12].

Rust's module system supports what's known as a re-export.

#+BEGIN_SRC rust
  pub mod file_mod;

  pub mod parent {
	  pub mod sibling1 {
		  use file_mod::func1;
	  }

	  pub mod sibling2 {
		  pub use file_mod::func1;
	  }

	  use sibling1::func1;
	  // Illegal
	  use sibling2::func1;
	  // Legal, re-export
  }
#+END_SRC

This allows programmers to present a flat structure to the end user, while retaining internal organisation.  The use keyword combined with the =as= keyword, allows renaming the values in the exported scope.

It is also a common practice to provide all the constructs that the user is likely to import in a single submodule known as a =prelude=.

Unlike the standard library prelude, it must be explicitly glob-imported.

#+BEGIN_SRC rust
  pub mod macro;

  pub mod prelude::{useful_function, macro::useful_macro, UsefulStruct};
#+END_SRC

** Overall

Rust is an average procedural language.

Compared to languages like FORTRAN and C, it is extremely difficult not to over-step the boundaries of the procedural subset; as such Rust is a poor substitute for code bases that only want to substitute a poorly supported procedural language, without adopting any aspects of either functional or OOP styles.

The experience of writing purely procedural Rust is akin to programming in PASCAL.  Despite the surgical adjustments, namely the introduction of slices, the restrictions imposed by the borrow checker contribute to a significantly slower development process as compared to C, or Go, in a purely procedural context.

As such, Rust should not be regarded as either exclusively or primarily procedural.

* Object Oriented Programming in Rust

Rust is a pragmatic OOP language.  It is as conceptually distant from a class-based OOP language (/e.g./ Java, C++) as it is from the Smalltalk family.  Rust has deliberately eschewed language features that serve to enable programmers to over-abstract and include too many indirections.  It has effective tooling for static and dynamic polymorphism.  Rust is also quite good at tracking objects properties, namely lifetimes.

It would be wise to think of Rust as an OOP language primarily, even though it is neither officially considered one by its creators, nor does it contain the typical feature set associated with OOP languages.

** Structs

Rust occupies a middle ground between traditional procedural POD sturctures and simula-style class-based structures.  For example:
#+BEGIN_SRC rust
  pub struct Complex {
	  pub real: f64,
	  pub imaginary: f64
  }
#+END_SRC
is a structure in Rust.  For example, here's how we construct an instance of this type,
#+BEGIN_SRC rust
  let number_two = Complex {
	  real: 2.0,
	  imaginary: 0.0
  }
#+END_SRC
in case there is a local variable with a suitable type, the colon can be omitted:
#+BEGIN_SRC rust
  let real = 2.0;
  let imaginary = 0.0;
  let number_two = Complex { real, imaginary };
#+END_SRC

Note that naming structures in Pascal case is strongly encouraged.  Failure to do so produces a compilation warning.  

Structures don't have a well-defined layout.  This implies that most Rust code links statically[fn:13], and intrinsically means that if two structures have different names, they must be treated as different types.

Specifically, in Rust there is no subtyping.  Each variable has precisely one type.  It doesn't matter if two structures have the same layout, they can neither be implicitly converted nor cast into each other.

Instead the conversion can be done explicitly
#+BEGIN_SRC rust
  pub struct 2dVec {
	  x: f64,
	  y: f64
  }

  let v = Complex { real: 2.0, imaginary: 3.0 };
  let v = 2dVec { x: v.real, y: v.imaginary }; // x and y are private
#+END_SRC
and in later chapters we shall see a more elegant way of performing the conversions.

Each structure has visibility modifiers, that act sensibly.  Public members are visible anywhere the structure is visible, =pub(crate)= and =pub(super)= allow access in the same library and the enclosing module respectively, and by default all fields are private.

Rust supports associating methods and functions to types, called inherent implementations:
#+BEGIN_SRC rust
  impl 2dVec {
	  pub fn new(x: f64, y: f64) -> Self {
		  Self {
			  x, y
		  }
	  }
  }
#+END_SRC
Note that when defining the associated factory function =new= we have used the shorthand =Self= for the name of the type.  This is to allow efficient renaming of structure.  We have also used the fact that the arguments of the function have the correct types and names to use the short-hand notation when constructing =Self=.

If a structure has even one field that is not public, it cannot be constructed with a constructor, and the factory method if visible is the only way to construct a new instance.  This also means that the fields cannot be read or written to if private.  The type, however, can be visible, but opaque.

Inherent implementations can be used to create getter and setter methods for private fields:
#+BEGIN_SRC rust
  impl 2dVec {
	  pub fn get_x(&self) -> f64 {
		  self.x
	  }

	  pub fn set_x(&mut self, other: f64) {
		  self.x = other;
	  }
  }
#+END_SRC
At which point they can be used as follows:
#+BEGIN_SRC rust
  let real = 2d_vec.get_x();
  2d_vec.set_x(real*2.0);
#+END_SRC
Notice that the first argument in the implementation does not have a type signature.  It is also used in the prefix notation, but that is no more than syntactic sugar.
#+BEGIN_SRC rust
  let real  = 2dVec::get_x(2d_vec);
  2dVec::set_x(&mut 2d_vec, real*2.0);
#+END_SRC
is what the previous syntax implies really.

It should be noted that getters and setters are extremely rare in Rust code bases.  The reason for this is the semantics of accepting a structure as a function argument.

The inherent implementations must be defined in the same translation unit (crate, but not necessarily the same module), as the structure.  It is illegal to define inherent implementations for structures defined in other libraries/crates.

** Traits

Rust took inspiration from Haskell in implementing a typeclass-like mechanism for polymorphism.  Instead of imposing a type hierarchy, Rust exposes a mechanism for defining an interface.  By default a new =struct= does not participate in any interface, and each structure's participation is a conscious decision made by the programmer.

Consider for a moment an interface that is not explicitly representable in C++ (until around C++ 20); namely that a type can be default constructed.  In Rust to specify that a type can be constructed with no input, one has to /implement/ the =Default= trait.

For a structure that we have defined: =Complex=, we can do so with the following construct:
#+BEGIN_SRC rust
  impl Default for Complex {
	  fn default() -> Self {
		  Self {
			  real: 0f64,
			  imaginary: Default::default()
			  // recursively call the default constructor for
			  // f64, which evaluates to 0.0
		  }
	  }
  }
#+END_SRC
To recap, we demonstrate that the type =Complex= participates in the =Default= interface.  We do so by implementing the unimplemented functions, and specifying any unspecified associated constants and types.

Anything that is true of an inherent implementation is true of a specific trait implementation.  So for example, we could implement =Default= for =2dVec= and use the constructor directly, without having to specify =pub(super)= setters.

Traits can be implemented either in the same crate as the structure, or the same crate as the trait.  So for example, if a foreign type, /e.g./  =std::vec::Vec=, does not already implement =Default= it is illegal to implement it.  This is known as the /orphan rule/.

** Pass by move

Rust is neither pass-by-copy (like C++) nor pass-by-reference (like Java).  Instead, all values are assumed to be passed by move.  Specifically for a function with the signature

#+BEGIN_SRC rust
  fn invert(mut number: Complex) -> Complex {
	  number.x = -number.x;
	  number.y = -number.y;
	  number
  }
#+END_SRC

despite the fact that the value =number= was passed as mutable, the memory locations associated to =complex1= and =complex2= aren't necessarily correlated:
#+BEGIN_SRC rust
  let complex1 = Complex::default();
  let complex2 = invert(complex1);
  // &complex1 != &complex2
  let complex3 = invert(complex1);
  // Error: complex1 is freed after the first call to `invert`
#+END_SRC
To help in this situation the trait =Clone= creates copies of objects to be used in functions that accept structures by move.

Specifically, we can implement clone in the following way
#+BEGIN_SRC rust
  impl Clone for Complex {
	  fn clone(&self) -> Self {
		  Self {
			  real: self.real,
			  imaginary: self.imaginary
		  }
	  }
  }
#+END_SRC
At which point we can modify the previous example:
#+BEGIN_SRC rust
  let complex1 = Complex::default();
  let complex2 = invert(complex1.clone());
  // &complex1 != &complex2, but complex1 is still valid
  let complex3 = invert(complex1.clone());
  // OK.
  let complex4 = invert(complex1);
  // Also fine.
#+END_SRC

So the C++ rule of three in Rust can be reduced to the creation of a factory method and implementing =Default= and =Clone=.

It must be noted, that the function call overheads when calling either the constructor function or the trait-associated function =clone=, is not always guaranteed to be optimised away.  Most =clone= implementations are recursive, and oftentimes, complex.  However, there are situations in which the bit representation of an object is the value of the object, and there is no difference between a shallow and deep copy.  Indeed our =Complex= type is just two =f64= numbers, which if copied with =memcpy= would still be a valid and /distinct/ value, which can be freed independently of the original.

To explain this to the compiler, we implement the =Copy= trait like so:
#+BEGIN_SRC rust
impl Copy for Complex {}
#+END_SRC
Note that simply marking =Complex= as copy does not involve implementing any function.

After this implementation, we can remove =Clone= as copies shall be done automatically by the compiler.

Rust does not support subtyping for structures, but it does support trait pre-requisites.  As such, if =Complex= did not implement =Clone= it would not be =Copy=.

This is not to say that each instance of pass-by-copy inserts or desugars to an insertion of =clone=.  If a value is marked as =Copy=, the cloning is done by replicating the bit-pattern and not recursively calling =clone=.

** Ownership, and =Drop=

Rust is a RAII language.  

* Footnotes

[fn:13] Although historically dynamic linkage was preferred.
[fn:12] This is most useful in using =enums= which we shall talk about later.

[fn:11] Which we have not covered in this section, as they do not work as strings in procedural languages.
[fn:10] As in =super::super= is not the parent of the parent.

[fn:9] That module is almost always a file =lib.rs= in the =src/= subdirectory of the project.

[fn:8] Out-parameters, are generally accepted, but not common.

[fn:7] A point that is somewhat frustrating to new users is that taking a mutable borrow invalidates any immutable borrows.

[fn:6] We shall see later, why the mutability nomenclature is somewhat misleading.

[fn:5] This situation is a newbie mistake when using the Rust =getopt= library.

[fn:4] The parallel to =return= is also in that a =break= without a value is assumed to "return" =()=.

[fn:3] The collection over which iteration takes place.

[fn:2] A full list is [[https://doc.rust-lang.org/reference/expressions.html][available here]].

[fn:1] One is generated via =cargo new=.
