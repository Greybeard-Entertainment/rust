#+TITLE: Rust in 2 hours
#+AUTHOR: Aleksandr Petrosyan

* Preface
This is a high level overview document about the Rust programming language.  The reason this document exists is to provide people who have to learn Rust at some point a general overview, without the usual dogmatism.  This is good to nudge teams that were considering Rust to using it and to avert catastrophe for projects for which it is a poor fit.

I firmly believe that either a blind endorsement or misinformed dogmatic rejection of the language are both detrimental to society.  Despite my humble expertise in Rust, and a relatively good overview of programming languages, I believe that this document can be a valuable tool.  However, this is in no way an in-depth analysis, and I would recommend using this document as a start for one's own research using the provided resources.

* Overview
Rust is a multi-paradigm programming language that supports procedural, object-oriented and functional programming as well as relatively niche paradigms such as actor-based programming.  However, it does not fit into either of those niches completely.  In conjunction with relatively good performance, a vibrant community and a reliance on the =libc= as the only runtime component, Rust can fill the niches previously occupied by C++, while its choice to support a limited form of compile-time user-specified code transformation/generation (via procedural macros) allow it to compete with Python and Go for backend development.

Rust is a complex language.  Much of its complexity stemming from the rules imposed by the language designers, rather than the sheer number of features.  Procedural macros allow library developers to impose additional rules, which more often than not allows Rust to be explored by trial and error.  For someone well-versed in Haskell and C++, required reading to learn Rust can be reduced to none, as the process from installing =rustup= to running =cargo build= is self documenting.

Rust is a language that plants itself firmly in the camp of pragmatic long feedback cycle development.  A proficient Rust engineer is able to skirt around and anticipate compilation errors, which given strict typing, strong soundness requirements and many issues particularly pertaining to incomplete and/or unimplemented features, is a lot harder than one would aniticipate.

Rust programming is unlike programming in other systems programming languages, as it does not allow the programmer to defer confronting problems, and over-abstract to hide poor design decisions.  It is a language best suited for programming libraries, with a similarly robust toolkit for producing complete applications either using the CLI or graphical toolkits.

It is a language that is used in the vast majority of blockchain systems.  Among the features that make it a good choice are
1) Borrow checking, which elides the need for garbage collection and  providing similar memory safety.
2) A sane concurrent programming paradigm, making it easier to write both threaded and asynchronous multiprocessing applications.
3) Strong static analysis tools, preventing implicit programming errors, such as over/under flow, unhandled error conditions, type mismatch etc.
4) Robust coverage of LLVM targets.  It should be noted that due to the dependence on the platform-specific =libc=, the =zig= programming language has slightly better coverage.
5) Rust is the preferred language for working with WASM both client and server-side.
6) Strong FFI programming paradigm.  One does not have an implicit ABI, and one has thorough control over memory layout as well as potential pitfalls.
7) Rust allows the user to specify additional compile-time constraints with thorough guidance via procedural macros.


Rust is used for the implementation of some of the ledgers in the Ethereum protocol, and all of the Solana software stack.  It is used in Parity Substrate (Polkadot ecosystem), and with very few exceptions is the language of choice for writing one's own blockchain protocol.

Finally, Rust is the first language since C to be used for the Linux kernel.  It was directly endorsed by the white house in lieu of traditional programming in "memory unsafe" languages such as C, C++, FORTRAN, Pascal, Ada, and many more.

It is a flourishing ecosystem of libraries, packages and professionals.

* Procedural Rust



Rust has a pragmatic approach to procedural programming.  In most situations, one is encouraged to write the code in a procedural style, without over-abstraction.

** Hello world
To start things off, this is what a hello-world program would look like[fn:1].
#+BEGIN_SRC rust
  fn main() {
	  println!("Hello world");
  }
#+END_SRC
The =main= function is an OS entrypoint.  The Rust compiler abstracts the unix-specific aspects of the entrypoint: note the absence of arguments as input, the usage of the =println!= macro in lieu of the =libc= =printf= function, lack of return in either the signature of main, or implicit =return 0=.  For all intents and purposes, these abstractions are almost never a problem, and allow the programmer to live in a world of coherent abstractions.

** TODO Crates, compilation, cargo

** Variables

Like many similar languages, Rust supports a Von-Neumann model:  variables can be regarded as containers for values.

Each container has exactly one type.  The following primitive numerical types are supported:

| Type |
|------|
| u8   |
| u16  |
| u32  |
| u64  |
| u128 |
#+CAPTION: Unsigned integer types

| Type |
|------|
| i8   |
| i16  |
| i32  |
| i64  |
| i128 |
#+CAPTION: Signed integer types

Each container must be initialised to a value, before use, that is of the same type as the container.  Failure to do so is a compilation error, Rust can keenly track these situations, more on that later.  The following is a comprehensive example of possible variable declarations.
#+BEGIN_SRC rust
  let good_type: u64 = 0_u64;
  let good_deferred_init;

  let mut inferred_type = 0_usize;
  let bad_value: u64 = -1_i32;	// bad: unsigned box, signed value
  let bad_type: u64 = 0_usize;	// bad: usize is not the same as u64
  good_deferred_init = 3;			// ok: type i32
  let bad_init;					// bad: not initialised at all
#+END_SRC

All variables must be initialised once.  The programmer must opt into mutating the value afterwards.

Each variable is confined to a scope, that is delimited by curly brace pairs.  A =let= expression can be used to shadow a variable within a particular scope, with a type that might be different.

#+BEGIN_SRC rust
  start = 0_i32;
  // Illegal, need `let`
  let start = 0_u8;
  // legal init
  let start = 0_i8;
  // legal shadow
  {
	  let mut start = 0_u16;
	  // legal shadow
	  start += 1_u16;					// No ++ operator :(
	  // legal, this `start` is mutable.
  }
  start -= 1_i8;
  // Illegal.

  let start: u128;
  // All legal
  start = 0_u64;
  // illegal, because the type of `start` must be `u128`
#+END_SRC



** Expressions, Control flow

Rust is an expression-based language.  An expression is composed of literals, variables, function calls, and operators[fn:2].  Variables are evaluated eagerly.  There are two distinct types, ones which indicate a location, (called place expressions) and the rest are value expressions.

All expressions produce a value, some expressions have an effect on the surrounding code.  A literal is an expression that only produces a value.  An assignment, by contrast produces both a value, and an effect, and arguably the effect is more important. All values produced by expressions can be assigned to a variable.

A block: region delimited by curly braces, is also an expression:
#+BEGIN_SRC rust
  let block = {
	  let answer = 22;
	  let question = 20;
	  question;
	  answer + question
  };
  // block == 42
  #+END_SRC
Note the absence of the semicolon in the line containing the expression =answer+question=, but the presence of a semicolon after the initialisation.  If the semicolon were added, this would still be valid Rust, but the value (and type) of block would be =()= known as =unit=.  This special type is what most expressions in Rust evaluate to, even though you as a programmer are unlikely to write it explicitly.

Rust supports many of the usual ALGOL-heritage control constructs.  This includes =if/else=, =while=, =for=.  In Rust, these constructs are also expressions, meaning that they produce a value.

The boolean conditional =if= works by evaluating the expression that follows the keyword, and then evaluating the contents of the following curly braces.  For example:

  #+BEGIN_SRC rust
	let value_of_if = if true { false; }
	// value_of_if == ()
#+END_SRC
An =if= is allowed to evaluate to the trivial type =()=.  Any other value with only one =if= would lead to inconsistency in the type of the =value_of_if= variable.

If the =if= has an =else= block, however, the value is allowed to be of any other type, provided both the types of the =if= and =else= are the same:
#+BEGIN_SRC rust
let answer: i32 = if question_about_meaning_of_life { 42 } else { -1 }
#+END_SRC

For obvious reasons, the =while= loop operates much like the lone =if= expression, evaluating to =()=.

The =for= loop operates more similarly to Python or PASCAL, in that it provides a bound value that is taken from a particular collection.  The precise mechanism for this we shall cover in a later chapter.  Similarly to =while= and despite there being a natural[fn:3] value to which the =for= expression could evaluate, it too evaluates to =()=.

These loops interact in the usual way with the =break= and =continue= keywords.  They typically either exit or skip the execution of statements in the first enclosing loop.  If there is more than one loop, the programmers disambiguate by assigning labels.

#+BEGIN_SRC rust
  'outer: for i in 1..=5 {
	  for j in 1..=200 {
		  if j > 4 {
			  break;
			  // equivalent to `continue 'outer;`
		  }
		  if i >= 2 {
			  break 'outer;
		  }
	  }
  }
#+END_SRC
One keyword that differentiates Rust from other programming languages is the =loop= keyword.  It is an endless loop, that must be exited with the =break= keyword, or not at all (/e.g./ in event loops, REPL /etc./).  This is also the reason for differentiating loop labels with single quote marks (/e.g./ ='outer= instead of =outer=); because =loop= expressions are allowed to evaluate to non-trivial values.  In this case =break= can be used as a regular =return= statement in a function[fn:4].

#+BEGIN_SRC rust
let (mut a, mut b) = (1, 1);
let result = loop {
	if b > 10 {
		break b;
	}
	let c = a + b;
	a = b;
	b = c;
};
#+END_SRC


#+BEGIN_ASIDE
This convention might seem problematic at first; indeed this was one of the main criticisms of Pascal.  However, this convention allows shorter code, that is also more explicit about the dependency chains.

It is a common situation where a lot of values must be constructed, so that then a few other dependent values are initialised.  This code if written out linearly is difficult to read, as it is a dry sequence of definitions and assignments.  However, if the base values are only needed to construct the dependent values, one can group those into anonymous blocks.

This can be extended to situations wherein state is being modified as well.  Imposing a scope and shadowing temporarily mutable values, allows one to know which values are yet to be mutated, and which are immutable.

This approach is reminiscent of [[http://number-none.com/blow/blog/programming/2014/09/26/carmack-on-inlined-code.html][style C of John Carmack]], but with crucial improvements.  Namely, the local variables are localised, the variables whose state is used more than once are naturally declared at the outer scope, giving one a structural insight into the code organisation.  The comments are optional, and the function of a code fragment can be gleaned from the value that is being constructed.  As such, it provides the sequential narrative of inline declarations, as well as the readability improvements associated to grouping logically connected operations.
#+END_ASIDE

** Arrays, borrows, slices

Rust supports contiguous homogeneously typed collections at the language level.  The following is an example of an array of bytes, that is the ASCII string for "hello world".
#+BEGIN_SRC rust
let array: [u8; _] = b"hello world";
#+END_SRC
In this example, we could have omitted the type signature, as it would be inferred.  We chose to specify the type of each element: =u8=, but not to specify the number of elements.  We have also chosen to use the array literal syntax for ASCII strings.  Including any UTF-8 non-ASCII characters would result in a compilation error.

Like in PASCAL, arrays of different lengths are considered different types.
#+BEGIN_SRC rust
  let array: [u8; 3] = b"hello world"; // Type error; length
  let array: [char; 3] = ['a', 'b', 'c']; // OK
  let array: [char; 4] = "abcd";			// OK
  let array: [u8; 4] = "abcd";			// Type error; char is not u8
  let array: [char, 4] = b"abcd";			// Type error; u8 is not the same type as char
#+END_SRC
It should also be noted, that =char= is a distinct type from =u8=, and that Rust strings (more on them later), are not arrays of either =char= or =u8=.  Consequently, the problems that plagued PASCAL do not affect Rust, for reasons that shall become clear shortly.

Rust does not support C/C++ style references and pointers.  For historical reasons Rust follows the convention of those languages for its closest analogues to those concepts, however, the semantics attached to those analogues are very different.

While variables typically have a memory address, unlike most procedural languages, Rust enforces that these memory addresses be taken only while the variables are in scope.  So for example the following code shall fail to compile:

#+BEGIN_SRC rust
  let reference: &i32;

  {
	  let temp = 0;
	  reference = &temp;
  }

  *reference = 42
  // UB: temp must be `free`d by now.
#+END_SRC

All addresses in Rust can be safely considered to be valid, unless a subsystem of the Rust compiler, known as the borrow checker, states that a variable, in this case =temp= doesn't live long-enough[fn:5].

For reasons that shall become apparent later, Rust refers to these addresses as borrows, to delineate that unlike in C, where taking a reference is a simple operation, in Rust, the same operation has more implications.  The inverse operation to a =borrow= is a =dereference= and it largely follows the same conventions as C.

Unlike C, a variable in Rust is only mutable if explicitly marked as mutable.  An even stricter requirement is imposed on references that are allowed to mutate the borrowed value, known as mutable borrows.  To mutate elements of an array, both the array itself as well as the borrow of said array must be marked explicitly as mutable.  For example:
#+BEGIN_SRC rust
  let mut vec: [u8; 3] = [1, 2, 3];

  for i in &mut vec {
	  *i += 50;
  }

  // vec = [51, 52, 53]
#+END_SRC

The borrow checker statically verifies that there is no converting an immutable reference to a mutable one, similar to casting away =const= in C.  Any attempt to take another mutable or immutable[fn:7] reference to the same array =vec= (for example inside the =for= loop)  would also be a compilation error, as only one mutable borrow is allowed at a time.

#+BEGIN_ASIDE
The borrow checker algorithm is not perfect; whenever it sees code that *could* be borrowing the same variable's address mutably twice, it will reject that code.

For situations where that would lead to great inefficiencies, users are to use =unsafe=, however, it is highly recommended to avoid =unsafe=, unless one has exhausted all other possibilities.
#+END_ASIDE

One final point to cover is references to arrays.  In Rust arrays of two different sizes have two different types.  This necessitates introducing two ways of borrowing an array: =&[u8; 3]= which is a single machine word "pointer" to the beginning of the array (with the size known at compile time), and =&[u8]=, a fat pointer containing the length as part of the runtime parameters, which is known as a slice.

Both use the same syntax, but given that compile time information provides room for optimisations, the programmer is given no control over which borrow occurs for any given scenario.

** Operators

Rust operators are strictly typed.  This means that in =a+b=, both =a= and =b= must be of the same type.  Some types, for which other languages provide an automatic coercion, /e.g./ =u8= to =u16=, must be explicitly cast to the appropriate type:
#+BEGIN_SRC rust
  let a = 1u8;
  let b = 2u16;
  let c = a + (b as u8);			// Truncation warning
  let d = (a as u16) + b;
  let err = a + b;				// Type Error
#+END_SRC

Rust permits truncating conversions, but the static analysis tool =clippy= is able to quickly find and warn about these problems.

Rust operators are overloaded and user-overload-able, via the =trait= mechanism which we shall cover in the object-oriented part of this book.  For the time being, suffice it to say that the plus operator that acts on =u16= is not the same as =+= acting on =u8=.  This shall become important when dealing with strings.

** Functions

Rust calls procedures[fn:8] functions, without differentiating side-effect-free functions from procedures.

Function signatures as well as argument type declarations are right-associative.

#+BEGIN_SRC rust
  fn function(arg1: u32, arg2: i32, arg3: u128) -> u128 {
	  arg3
  }
#+END_SRC
Functions  evaluate to the value of the block that constitutes its body.  In this example the function body could be rewritten to =return arg3;= without changing anything.

No type outside the function body is inferred, so the function must always specify the type of each argument.

All data that the function is allowed to read comprises its arguments and special global values defined using the =const= keyword.  For the time being it can be assumed that this implies that no global shared state is permitted, but as we shall see later, this is not the case.

The functions must rigidly adhere to the type signature.  No implicit conversions in standard functions is permitted to occur, so arguments must be explicitly cast at the call site.

Functions that do not participate in C-ABI linkage are not variadic.

** Introduction to Macros

Macros are one of the key differentiating factors of Rust from other systems programming languages.  Macros are typically used to generate valid Rust code that no reasonable human being would be able to interpret or write, in addition to imposing other restrictions.

Macros do not have access to the type system, but thanks to strict typing, macros can typically do rudimentary type checking by hijacking the type checking in the generated code.

As such, there are multiple types of macros, of which we shall only cover one type: function-like macros.

Unlike functions, which have a fixed number of arguments, and are strictly type checked, a function-like macro can accept any form of input.  Technically all macros accept one argument, but that argument can be a delimited collection of expressions, which act as if they were a variadic function or macro.

We have already seen one example, the =println!= macro.  All function like macros are postfixed by an exclamation mark to differentiate them from functions.

** The formatting mini-language

The =println= macro is worth going into.  The first "argument" of =println!= is a format "string".  Unlike =printf= in C, this argument string is not an actual string[fn:11], and must be specified in-line as a string literal.  This format string is parsed at compilation time, and if there are no format markers, the string is printed as is.

The format markers constitute a mini-language.  Most primitive types can be printed directly, via an empty pair of curly braces:
#+BEGIN_SRC rust
  let answer = 42;
  println!("Hello world! The answer is {}", answer);
#+END_SRC
The empty pair is called a positional format marker, and for each positional format marker, there must be a comma delimited in-line list of variables that must be printed, in the order specified by positional format markers.

Named format markers allow one to assign a name in the format string, and in the variable list, assign variables to the named markers.  If the name of the format marker corresponds to an in-scope variable, the assignment can be omitted.

#+BEGIN_SRC rust
  let world_ordinal = 3;
  println!("Hello World number {world}! The answer is {answer}", world=world_ordinal)
#+END_SRC

#+BEGIN_ASIDE
My personal recommendation is to consider using /named/ format markers almost always; definitely in cases where there's more than one format marker.

Additionally, I should advise against mixing positional and named markers.
#+END_ASIDE

One has access to a rich set of formatting options, including
- fill,
- alignment,
- width
- formatting of numerical literals in many bases, including binary, hexadecimal, octal.
- Precision control for floating point numbers
- Localisation (for locales where the decimal separator is different) etc.

#+BEGIN_ASIDE
The =println!= and =eprintln!= macros (printing to =stderr=) are included in the so-called prelude.  This is a collection of commonly used constructs that are imported by default.
#+END_ASIDE


** Modules

Rust has a robust system of modules and namespaces.  Many objects, including constants, functions and modules accept visibility modifiers.  Everything is private by default, unless specified otherwise by prefixing the =pub= keyword.

Modules constitute a tree, with one root, known as the top-level module[fn:9].  The nested modules can refer to the top level module as =crate=, and their immediate[fn:10] parent module as =super=.   To access members within a module, one uses the =::= syntax borrowed from C++.

#+BEGIN_SRC rust
  pub mod thing {
	  pub const CONST: u8 = 32;

	  mod thing2 {
		  pub const CONST: u8 = 42;
		  // Warning, module private, can't see the `pub`.
	  }

	  pub(super) thing3 {
		  pub const CONST: u8 = 42;
	  }
	  pub const CONST2: u8 = thing3::CONST;
  }

  mod thing2 {
	  pub const CONST: u8 = super::thing::CONST;
	  pub mod thing3 {
		  pub const CONST: u8 = crate::thing::CONST;
		  // This is identical to `thing2::CONST`
	  }
	  pub const CONST2: u8 = super::thing::thing3::CONST;
	  // Error, thing3 is visible to `thing`
  }

  mod file_mod;			// Lives in a file `file_mod.rs`
#+END_SRC

All constructs must be either fully qualified or imported with the =use= keyword.

#+BEGIN_ASIDE
Unlike C++, the usage of =use= is not problematic.  Rust does not allow two functions with separate definitions to be imported into the same namespace, so a functional call always resolves unambiguously and the definition even for generic functions is always local.
#+END_ASIDE

The =use= keyword allows shorthand import of multiple constructs, with short-hand notation for all public items belonging to a particular module.

#+BEGIN_SRC rust
  use file_module::submod::{fun1, fun2, self}
  // Allows referring to `submod::` directly

  mod file_module;
  // The mod declaration can come after the imports

  pub mod thing {
	  use super::*;
	  // modules don't inherit parent imports
  }
#+END_SRC

Use statements are effective for the block in which they are written.  So, having use statements confined to a block is useful when one wants to avoid using fully-qualified paths[fn:12].

Rust's module system supports what's known as a re-export.

#+BEGIN_SRC rust
  pub mod file_mod;

  pub mod parent {
	  pub mod sibling1 {
		  use file_mod::func1;
	  }

	  pub mod sibling2 {
		  pub use file_mod::func1;
	  }

	  use sibling1::func1;
	  // Illegal
	  use sibling2::func1;
	  // Legal, re-export
  }
#+END_SRC

This allows programmers to present a flat structure to the end user, while retaining internal organisation.  The use keyword combined with the =as= keyword, allows renaming the values in the exported scope.

It is also a common practice to provide all the constructs that the user is likely to import in a single submodule known as a =prelude=.

Unlike the standard library prelude, it must be explicitly glob-imported.

#+BEGIN_SRC rust
  pub mod macro;

  pub mod prelude::{useful_function, macro::useful_macro, UsefulStruct};
#+END_SRC

** Overall

Rust is an average procedural language.

Compared to languages like FORTRAN and C, it is extremely difficult not to over-step the boundaries of the procedural subset; as such Rust is a poor substitute for code bases that only want to substitute a poorly supported procedural language, without adopting any aspects of either functional or OOP styles.

The experience of writing purely procedural Rust is akin to programming in PASCAL.  Despite the surgical adjustments, namely the introduction of slices, the restrictions imposed by the borrow checker contribute to a significantly slower development process as compared to C, or Go, in a purely procedural context.

As such, Rust should not be regarded as either exclusively or primarily procedural.

* Object Oriented Programming in Rust

Rust is a pragmatic OOP language.  It is as conceptually distant from a class-based OOP language (/e.g./ Java, C++) as it is from the Smalltalk family.  Rust has deliberately eschewed language features that serve to enable programmers to over-abstract and include too many indirections.  It has effective tooling for static and dynamic polymorphism.  Rust is also quite good at tracking objects properties, namely lifetimes.

It would be wise to think of Rust as an OOP language primarily, even though it is neither officially considered one by its creators, nor does it contain the typical feature set associated with OOP languages.

** Structs

Rust occupies a middle ground between traditional procedural POD sturctures and simula-style class-based structures.  For example:
#+BEGIN_SRC rust
  pub struct Complex {
	  pub real: f64,
	  pub imaginary: f64
  }
#+END_SRC
is a structure in Rust.  For example, here's how we construct an instance of this type,
#+BEGIN_SRC rust
  let number_two = Complex {
	  real: 2.0,
	  imaginary: 0.0
  }
#+END_SRC
in case there is a local variable with a suitable type, the colon can be omitted:
#+BEGIN_SRC rust
  let real = 2.0;
  let imaginary = 0.0;
  let number_two = Complex { real, imaginary };
#+END_SRC

Note that naming structures in Pascal case is strongly encouraged.  Failure to do so produces a compilation warning.

Structures don't have a well-defined layout.  This implies that most Rust code links statically[fn:13], and intrinsically means that if two structures have different names, they must be treated as different types.

Specifically, in Rust there is no subtyping.  Each variable has precisely one type.  It doesn't matter if two structures have the same layout, they can neither be implicitly converted nor cast into each other.

Instead the conversion can be done explicitly
#+BEGIN_SRC rust
  pub struct 2dVec {
	  x: f64,
	  y: f64
  }

  let v = Complex { real: 2.0, imaginary: 3.0 };
  let v = 2dVec { x: v.real, y: v.imaginary }; // x and y are private
#+END_SRC
and in later chapters we shall see a more elegant way of performing the conversions.

Each structure has visibility modifiers, that act sensibly.  Public members are visible anywhere the structure is visible, =pub(crate)= and =pub(super)= allow access in the same library and the enclosing module respectively, and by default all fields are private.

Rust supports associating methods and functions to types, called inherent implementations:
#+BEGIN_SRC rust
  impl 2dVec {
	  pub fn new(x: f64, y: f64) -> Self {
		  Self {
			  x, y
		  }
	  }
  }
#+END_SRC
Note that when defining the associated factory function =new= we have used the shorthand =Self= for the name of the type.  This is to allow efficient renaming of structure.  We have also used the fact that the arguments of the function have the correct types and names to use the short-hand notation when constructing =Self=.

If a structure has even one field that is not public, it cannot be constructed with a constructor, and the factory method if visible is the only way to construct a new instance.  This also means that the fields cannot be read or written to if private.  The type, however, can be visible, but opaque.

Inherent implementations can be used to create getter and setter methods for private fields:
#+BEGIN_SRC rust
  impl 2dVec {
	  pub fn get_x(&self) -> f64 {
		  self.x
	  }

	  pub fn set_x(&mut self, other: f64) {
		  self.x = other;
	  }
  }
#+END_SRC
At which point they can be used as follows:
#+BEGIN_SRC rust
  let real = 2d_vec.get_x();
  2d_vec.set_x(real*2.0);
#+END_SRC
Notice that the first argument in the implementation does not have a type signature.  It is also used in the prefix notation, but that is no more than syntactic sugar.
#+BEGIN_SRC rust
  let real  = 2dVec::get_x(2d_vec);
  2dVec::set_x(&mut 2d_vec, real*2.0);
#+END_SRC
is what the previous syntax implies really.

It should be noted that getters and setters are extremely rare in Rust code bases.  The reason for this is the semantics of accepting a structure as a function argument.

The inherent implementations must be defined in the same translation unit (crate, but not necessarily the same module), as the structure.  It is illegal to define inherent implementations for structures defined in other libraries/crates.

** Traits

Rust took inspiration from Haskell in implementing a typeclass-like mechanism for polymorphism.  Instead of imposing a type hierarchy, Rust exposes a mechanism for defining an interface.  By default a new =struct= does not participate in any interface, and each structure's participation is a conscious decision made by the programmer.

Consider for a moment an interface that is not explicitly representable in C++ (until around C++ 20); namely that a type can be default constructed.  In Rust to specify that a type can be constructed with no input, one has to /implement/ the =Default= trait.

For a structure that we have defined: =Complex=, we can do so with the following construct:
#+BEGIN_SRC rust
  impl Default for Complex {
	  fn default() -> Self {
		  Self {
			  real: 0f64,
			  imaginary: Default::default()
			  // recursively call the default constructor for
			  // f64, which evaluates to 0.0
		  }
	  }
  }
#+END_SRC
To recap, we demonstrate that the type =Complex= participates in the =Default= interface.  We do so by implementing the unimplemented functions, and specifying any unspecified associated constants and types.

Anything that is true of an inherent implementation is true of a specific trait implementation.  So for example, we could implement =Default= for =2dVec= and use the constructor directly, without having to specify =pub(super)= setters.

Traits can be implemented either in the same crate as the structure, or the same crate as the trait.  So for example, if a foreign type, /e.g./  =std::vec::Vec=, does not already implement =Default= it is illegal to implement it.  This is known as the /orphan rule/.

** Pass by move

Rust is neither pass-by-copy (like C++) nor pass-by-reference (like Java).  Instead, all values are assumed to be passed by move.  Specifically for a function with the signature

#+BEGIN_SRC rust
  fn invert(mut number: Complex) -> Complex {
	  number.x = -number.x;
	  number.y = -number.y;
	  number
  }
#+END_SRC

despite the fact that the value =number= was passed as mutable, the memory locations associated to =complex1= and =complex2= aren't necessarily correlated:
#+BEGIN_SRC rust
  let complex1 = Complex::default();
  let complex2 = invert(complex1);
  // &complex1 != &complex2
  let complex3 = invert(complex1);
  // Error: complex1 is freed after the first call to `invert`
#+END_SRC
To help in this situation the trait =Clone= creates copies of objects to be used in functions that accept structures by move.

Specifically, we can implement clone in the following way
#+BEGIN_SRC rust
  impl Clone for Complex {
	  fn clone(&self) -> Self {
		  Self {
			  real: self.real,
			  imaginary: self.imaginary
		  }
	  }
  }
#+END_SRC
At which point we can modify the previous example:
#+BEGIN_SRC rust
  let complex1 = Complex::default();
  let complex2 = invert(complex1.clone());
  // &complex1 != &complex2, but complex1 is still valid
  let complex3 = invert(complex1.clone());
  // OK.
  let complex4 = invert(complex1);
  // Also fine.
#+END_SRC

So the C++ rule of three in Rust can be reduced to the creation of a factory method and implementing =Default= and =Clone=.

It must be noted, that the function call overheads when calling either the constructor function or the trait-associated function =clone=, is not always guaranteed to be optimised away.  Most =clone= implementations are recursive, and oftentimes, complex.  However, there are situations in which the bit representation of an object is the value of the object, and there is no difference between a shallow and deep copy.  Indeed our =Complex= type is just two =f64= numbers, which if copied with =memcpy= would still be a valid and /distinct/ value, which can be freed independently of the original.

To explain this to the compiler, we implement the =Copy= trait like so:
#+BEGIN_SRC rust
impl Copy for Complex {}
#+END_SRC
Note that simply marking =Complex= as copy does not involve implementing any function.

After this implementation, we can remove =Clone= as copies shall be done automatically by the compiler.

Rust does not support sub-typing for structures, but it does support trait pre-requisites.  As such, if =Complex= did not implement =Clone= it would not be =Copy=.

This is not to say that each instance of pass-by-copy inserts or desugars to an insertion of =Clone::clone=.  If a value is marked as =Copy=, the cloning is done by replicating the bit-pattern and not recursively calling =clone=.

** Polymorphism
*** Trait-associated functions, turbofish

We are now equipped to tackle the question of how Rust achieves polymorphism.  There are several mechanisms that work concurrently and all of them revolve around traits.

Let us first start by noting that there can be only one free-standing function for any given name.   This extends to inherent implementations.  Though an inherent implementation can have the same name as a freestanding function:
#+BEGIN_SRC rust
  fn hello() {
	  println!("hello")
  }

  impl Complex {
	  pub fn hello() -> {
		  println!("hello again")
	  }
  }
#+END_SRC
there can be only one inherent implementation with a given name.  A trait can also only be implemented once.

Since both the trait-associated and inherent implementations share the call syntax, whenever there may be ambiguity Rust requires the programmer to disambiguate manually:
#+BEGIN_SRC rust
  let clone = Object::clone(&object); // inherent
  let clone = <Object as Clone>::clone(&object); // associated to the `Clone` trait
#+END_SRC
the syntax =<Type as Trait>::method= is sometimes called the turbofish.

A function associated to a trait can be called only if that trait is in scope.  The trait =Clone= is imported as part of the standard library =prelude=, but other traits must be imported manually before use.  If two traits have an associated function of the same name, each =.method= call must be rewritten as =<Type as Trait>::method= turbofish.  This is technically a form of static polymorphism, but not particularly interesting.

*** Generics
**** Structure and function basics, trait bounds
Rust supports generics via templates.  Like in C++ both structures and functions can be made generic.  What this means is that for each instance of a generic structure template, a new structure definition is created.  These structures are considered distinct types in all but generic functions.
#+BEGIN_SRC rust
  struct Complex<T: Copy + Default> {
	  real: T,
	  imaginary: T
  }
#+END_SRC
In this example we specify that =Complex= is a generic structure parameterised by a single type =T=, that can only be a type that is both trivially =Copy=-able and =Default=-constructable.  We know that if =Complex<Sometype>= is a valid type, then =Sometype= must implement both traits.   In C++, this isn't always the case, and usage of C++ concepts is complicated enough that these cases are the minority.

Methods for generic structures must also be generic.
#+BEGIN_SRC rust
  impl<T: Default + Copy> Complex<T> {
	  pub fn new(real: T, imaginary: T) -> Self {
		  Self { real, imaginary }
	  }
  }
#+END_SRC
Note that we must provide constraints which are at least the same or more constraining than the ones that we have provided in the structure definition.  So for example adding =T: Default + Copy + PartialEq= to the =impl= generic arguments, would entail that the generic functions defined in that block are only defined if =T= satisfies =PartialEq= in addition to the constraints imposed in the structure definition.

#+BEGIN_SRC rust
  impl<T: Default + Copy + PartialEq + Eq> Complex<T> {
	  pub fn is_default(&self) -> bool {
		  self.real == T::default() && self.imaginary == T::default()
	  }
  }
#+END_SRC
In this example, we rely on the fact that if a type =T= implements both =PartialEq= which defines the equality operation and =Eq= which states that for all valid values of =T= an equality comparison has all the usual properties, and always yields a boolean value, then we can ask of =Complex<T>= if it is the =default=.

**** Blanket implementations
The above example is for illustration purposes only; most new programmers in Rust will fall into a few common traps which we shall mention here, and fix later.

Specifically, we assume that the implementation of =Complex<T>::default= is recursive and comprises the defaults of =real= and =imaginary=.  This is true assuming no other code exists, but may not be true in general.  In fact, assuming the code that we have presented as examples is the only code that there is, the concept of =Complex<T>::default= is not defined.  So we should provide an implementation for that:
#+BEGIN_SRC rust
  impl<T: Default + Copy> Default for Complex<T> {
	  fn default() -> Self {
		  Self {
			  real: T::default(),
			  imaginary: Default::default(), // Type T inferred, identical to above
		  }
	  }
  }
#+END_SRC
This is called a /blanket implementation/, as it covers more than one type =T= in this set.  Blanket implementations are useful, but not as much as one might expect at first glance, because unfortunately, trait implementations that can overlap either now or hypothetically in the future, are both covered by a blanket implementation there is a conflict that cannot be resolved at present.

In this example we must note that if we had omitted the =Default= trait bound in the definition of =Complex<T>= we would still have a sound set of functions.  It is only sensible to consider if =Complex<T>= is the default if said default is defined.  But due to the constraints inherent in Rust's trait system, we would not be able to define =is_default= as easily, so we have chosen to require that the =T= be =Default= for all valid =Complex<T>= types.  We shall see later how this could be done with more sophisticated =where= clauses.

#+BEGIN_aside
Because of the way that this system is set up, we can always know for certain where the function called in each particular case is defined.  One knows that a function can only be defined once, and never overloaded, so a regular expression search is all one needs to find where a particular function is defined.
#+END_aside

**** =From= and =Into=

One of the most important applications of generic functions is in conversions between types.  In general only numerical types and pointers can be cast using the =as= keyword.  Every other kind of conversion is done via either =From=, =Into= or =AsRef=.

These traits cover the different possible conversions scenarios, so it is worth exploring them.

=From= should be the first trait to consider.  It simply states that two types can be infallibly converted into one another.   A good example is considering how we can convert an array of floating point numbers into =Complex<f64=.

#+BEGIN_SRC rust
  impl From<[f64;2]> for Complex<f64> {
	  fn from(value: [f64; 2]) -> Self {
		  Self { real: value[0], imaginary: value[1] }
	  }
  }
#+END_SRC

This can be invoked like so
#+BEGIN_SRC rust
  let complex = Complex::from([1.0, 0.0]);
#+END_SRC

Here we can demonstrate the importance of providing blanket implementations.  Suppose we had a function which accepts =Complex<f64>= as an argument, /e.g./
#+BEGIN_SRC rust
  fn rotate_90(number: Complex<f64>) -> Complex<f64>;
#+END_SRC
we can now invoke this function in a way which closely mimics implicit conversions:
#+BEGIN_SRC rust
  rotate_90([1.0, 0.0].into())
#+END_SRC
This all because for all types =A=, and =B= such that each =B= implements =From<A>= the inverse trait =Into<B>= is implemented for each =A=.  As such, one gets two trait implementations at the cost of one.  Unfortunately, implementing =Into<B>= for some =A= does not automatically implement =From<A>= for =B=, at least not yet, so one should always consider implementing =From= if possible.

**** Custom traits

The Rust programmer is encouraged to introduce traits.  A typical trait definition is akin to an interface in Java.  Traits can have associated types, associated constants, and associated functions.  Each can have a default implementation that can also be overridden for each concrete type.
#+BEGIN_SRC rust
  pub trait HaveItAll {
	  pub const DEFAULT_CONST: u32 = 0;
	  pub type DefaultType = u32;
	  pub type MustBeClone: Clone;
	  pub const CONST: MustBeClone;

	  fn get_const(&self) -> Self::MustBeClone {
		  Self::CONST
		  // Can override
	  }

	  fn must_implement(&self, other: Self::DefaultType) -> Self::MustBeClone;
  }
#+END_SRC

In Rust a trait can require the implementation of another trait known as a /supertrait/.  Trait inheritance is the only kind of inheritance that Rust supports.
#+BEGIN_SRC rust
  pub trait CopyExtension: Clone + Debug {
	  fn copy(&self) -> Self {
		  println!("{:?}", self);
		  self.clone()
	  }
  }
#+END_SRC




**** Ownership, and =Drop=


Rust is a RAII language.  This coupled with the borrow checking rules implies that one can safely de-allocate any structure as soon as it reaches the end of the scope in which it is defined.  But this is only true of simple structures, those that implement =copy= as some structures may need to perform complex housekeeping to safely stop existing.

In Rust, the role of destructors is filled in with the =Drop= trait and the associated function =Drop::drop=, using its fully qualified name.  The function is called recursively for types that implement it, and for types that contain types that implement recursively.

#+BEGIN_SRC rust
  struct HasDrop;

  impl Drop for HasDrop {
	  fn drop(&mut self) {
		  println!("Dropping HasDrop!");
	  }
  }

  struct HasRecursiveDrop {
	  one: HasDrop,
  }

  fn main() {
	  let _x = HasRecursiveDrop { one: HasDrop };
  }
#+END_SRC

In this example, even though technically there isn't an explicit implementation of =Drop= for =HasRecursiveDrop= the =<HasDrop as Drop>::drop= function shall be called and the =dropping HasDrop!= message shall be printed.

This lends itself to the notion of ownership.  A field in a structure is owned by that structure.  The structure is responsible for both creating and de-allocating the field.

This however means that each object must have precisely one owner.  And all objects that exist within the program must be traceable to a few objects created in =main.rs= either directly or indirectly.   Instead of having a class hierarchy, Rust opts to have an object hierarchy.

In Rust, this allows one to effortlessly use types that manage resources externally.  This leads to some quirks, that should be noted.
For example, if a value is returned from a function it must be bound to a variable, otherwise its destructor is called immediately.

#+BEGIN_SRC rust
  let _keep_alive = SomeStruct::long_running_task_handle();
#+END_SRC
in such circumstances it is common to see the following construct.  Also note the underscore in the =_keep_alive=; without it the static analyser will warn about =keep_alive= being unused.  So be cautious of naming your variables, including fields with underscores prefixed or postfixed.

**** =AsRef=, =Deref= and Smart pointers

The reason why we needed to cover ownership was to introduce the concept of a smart pointer.

To cover ground where ownership hierarchies are unsuitable, Rust borrowed an idea from C++11.  Namely to create special wrapping types known as smart pointers whose construction is meant to replicate manual memory management patterns on types, without the programmer writing boilerplate.

=Box<T>= is a unique pointer to a heap-allocated =T= that de-allocates the heap memory when it goes out of scope.  =Rc<T>= is a reference counted pointer that is used when multiple objects need to share a resource.  =Arc= is atomically-reference counted which can be used when the objects referencing the shared object are in different threads.

The mechanism by which the use of these smart pointers is practical is known as dereference aliasing.  Implementing the trait =AsRef<T>= signals to the programmer and the compiler that the object in question can give a reference to a valid structure of type =T=.  For example,
#+BEGIN_SRC rust
  pub struct Zoo {
	  ape: Ape,
	  crocodile: Crocodile,
	  parrot: Parrot,
  }
#+END_SRC
can reasonably provide implementations for =AsRef<Ape>=, =AsRef<Crocodile>= and =AsRef<Parrot>=, even though this usage is discouraged[fn:14].

Implementing the trait =Deref= signals to the compiler that the object should be regarded as a pointer to the type =T=.  Specifically, in
#+BEGIN_SRC rust
  let boxed_parrot = Box::new(Parrot::default());

  boxed_parrot.parrot_method();
#+END_SRC
because =Box<Parrot>= implements =Deref= with the associated type =Target= set to =Parrot=, or in Rust notatoin =Deref<Target=Parrot>= the call to the function =parrot_method= is unambiguous, and no further indirection is needed.

#+BEGIN_aside
While it is tempting to use these traits to create a form of object inheritance, this is strongly discouraged.  The =Deref= and =AsRef<T>= traits should only be implemented if one truly wishes to represent a pointer to a type, as this is the intention being communicated.
#+END_aside

*** Trait objects

The final and most delicate mechanism is late binding.

Rust supports dynamic dispatch via type erasure and so-called fat-pointers[fn:15].  Because the sizes of all implementations of a certain trait are not guaranteed to be identical, one must do explicitly in Rust what Java does implicitly.  Namely all dynamically dispatched objects in Rust must be heap-allocated and managed via borrow/smart pointer.

The most common application is a heterogeneous collection of objects that implement the same trait, in error handling, but these objects can be used directly by borrow, consider the trait defined as
#+BEGIN_SRC rust
  trait HasNorm {
	  fn norm(&self) -> f64;
  }

  impl HasNorm for Complex<f64> {
	  fn norm(&self) -> f64 {
		  self.real * self.real + self.imaginary * self.imaginary
	  }
  }


  impl HasNorm for Complex<f32> {
	  fn norm(&self) -> f64 {
		  (self.real * self.real + self.imaginary * self.imaginary) as f64
		  // Demonstration purposes only
	  }
  }
#+END_SRC

we can define a polymorphic function that can accept either a reference to =Complex<f64>= or =Complex<f32>=, or any type that implements =HasNorm= as follows:

#+BEGIN_SRC rust
  fn modulus(value: &dyn HasNorm) -> f64 {
	  let norm = value.norm();
	  norm.sqrt()
  }
#+END_SRC

This approach is different to /e.g./
#+BEGIN_SRC rust
  fn modulus<T: HasNorm>(value: &T) -> f64 {
	  let norm = value.norm();
	  norm.sqrt()
  }
#+END_SRC
in the following way.  The dynamically dispatched function exists in one place.  If for example, we have \(n\) functions defined as dynamically dispatched, and \(m\) implementations of =HasNorm=, then there are \(n\) functions and \(m\) vtables.  By contrast each generic function is instantiated for each implementor of =HasNorm=.   We have a multiplicative explosion of code paths, a reduction in code locality, in exchange for potentially[fn:16] better performance if the virtual calls can be converted to different code paths.

There are situations in which trait-object based code is clearer, particularly if the concrete type is too verbose or necessitates a large number of trait bounds to be repeated.  More on that later.

Dynamic dispatch imposes its limitations.  Type erasure means that only the information about the objects implementation of a particular trait can be used.  For example, if the object was converted to =&dyn HasNorm= and there is neither a supertrait nor a blanket implementation of =Debug= for all implementors of =HasNorm=, then an said object can no longer be printed.

#+BEGIN_aside
One example of inconvenience imposed by type erasure is the =std::io::Error= type.  It wraps a =Box<dyn std::error::Error>= trait object, as a result of which a =std::io::Error= objects cannot be cloned.  While there are ways of making trait objects =Clone= almost all of them involve changing the trait, which in case of =std::error::Error= would result in almost all Rust code being broken.
#+END_aside

** Encapsulation

Rust provides a robust set of interlocking features that make it an excellent language to write encapsulated code.

We have noted earlier that it is exceedingly rare to see =getters= and =setters= in Rust, and even then more often than not, as a result of needing to manipulate Rust objects from a different programming language via a Foreign function interface (FFI).

This is because the borrow checker and immutable-by-default variables impose enough restrictions to preserve structure invariants by other methods.  Because one does not have inheritance, one has to choose composition.  Because most values are passed by move and immutable, one is encouraged to construct new values instead of mutating the old ones in place.

Technically speaking the only other place where Rust getters and setters are used in earnest are in the builder pattern, but even then they are used as syntactic sugar for constructing a new value, rather than for the purposes of preserving an invariant.  Because it is easier to construct a new immutable value, the focus in Rust has shifted away from imposing instance invariants towards type invariants enforced at construction and propagated by immutability.

To demonstrate the difference in philosophy consider the following example.  When implementing a builder for a type in Rust, one is ordinarily accepting =self= by move and returning a new value.

This permits a pipeline style that was popularised in Java with the introduction of anonymous functions, and in C++ with the introduction of ranges.
#+BEGIN_SRC rust
  let thing: File = OpenOptions::new()
	  .read(true)
	  .open(path)
#+END_SRC

Unfortunately, there are situations in which shared data indeed needs to be mutated.  For example the database in a server must be mutable and able to respond to requests handled by, potentially, different threads.

In Rust, immutable borrows aren't really immutable, but encapsulated.  By that I mean that =RefCell=, =Mutex=, =RwLock=,  the numerical types in =std::sync::atomic=, all allow mutating the state of objects through an immutable borrow.  The logic behind this is that if the programmer knows what they are doing, they can safely mutate shared state.  The preferred way to do this, is by relying on the programmers of the Rust standard library or any of the crates on crates.io, to have ensured that mutation via the public API of =Mutex= does not produce undefined behaviour, or errors due to concurrent modification.




*** TODO Mention pointers and unsafe
*** TODO Mention array index notation in the /procedural/ chapter
* Appendix

**** Worked example: custom traits

We must now consider how one can define traits, on a practical example.  The above =Complex<T>= structure definition allows one to construct types that are not sensible: for example =Complex<bool>= or =Complex<char>=.  We would like to differentiate the primitive types that represent numbers from other general primitive types.

#+BEGIN_SRC rust
  pub trait Numerical {}
#+END_SRC
Our first stop is what's called a /marker trait/.  The implementation of this trait is low-effort and can theoretically be done for all possible types.  For example,
#+BEGIN_SRC rust
  impl Numerical for u64 {}
#+END_SRC
/marks/ =u64= as =Numerical=.

We can assume that given that we are not going to have such statements for =char= and =bool= that amending the structure definition of =Complex<T>= to
#+BEGIN_SRC rust
  pub struct Complex<T: Numerical> {
	  real: T,
	  imaginary: T
  }
#+END_SRC
would be enough.  But this will result in =Complex<T>= being rather awkward to use.  At present it can neither be cloned nor printed, nor indeed compared for equality.  Arithmetic cannot be defined over complex numbers, because having a generic function of the form
#+BEGIN_SRC rust
  impl<T: Numerical> Complex<T> {
	  fn norm(&self) -> T {
		  self.real * self.real + self.imaginary * self.imaginary
	  }
  }
#+END_SRC
would not compile.

So at this point we must consider which properties of =T= are intrinsic to =Complex<T>= being useful as a complex number, and which are helpful, but not required.

Firstly, consider how a complex number is defined in abstract mathematical terms and how that definition is different from /e.g./  a two dimensional vector.




* Footnotes
[fn:16] While writing code via generics guarantees that it will be monomorphically dispatched, trait object code can also be de-virtualised by LLVM.


[fn:15] The slice is an example of a fat pointer, in that =&[u8]= is both a reference to the first element of the array, and the length of said array.

[fn:14] The reason is simple.  If your function accepts a =&Parrot= you should invoke =&zoo.parrot=, rather than =zoo.as_ref()=.

[fn:13] Although historically dynamic linkage was preferred.
[fn:12] This is most useful in using =enums= which we shall talk about later.

[fn:11] Which we have not covered in this section, as they do not work as strings in procedural languages.
[fn:10] As in =super::super= is not the parent of the parent.

[fn:9] That module is almost always a file =lib.rs= in the =src/= subdirectory of the project.

[fn:8] Out-parameters, are generally accepted, but not common.

[fn:7] A point that is somewhat frustrating to new users is that taking a mutable borrow invalidates any immutable borrows.

[fn:6] We shall see later, why the mutability nomenclature is somewhat misleading.

[fn:5] This situation is a newbie mistake when using the Rust =getopt= library.

[fn:4] The parallel to =return= is also in that a =break= without a value is assumed to "return" =()=.

[fn:3] The collection over which iteration takes place.

[fn:2] A full list is [[https://doc.rust-lang.org/reference/expressions.html][available here]].

[fn:1] One is generated via =cargo new=.
